# 구스구스덕 - 네트워크 프로젝트

# **Ⅰ.** 개요

## 한 줄 소개

Photon을 활용한 네트워크 게임을 구현하였으며, 마피아류 게임인 구스구스덕을 모작함하였음

## 개발 환경

개발기간 : 2024.11.20 ~ 2024.12.05

인원 : 4인 (개발 4인)

사용 툴 : Unity Engine 2021.3.42f1, Visual Studio 2022, Git, Github, Photon

## 게임 규칙 

- 오리 / 거위 두 종류의 직업군으로 분류
- 거위들은 맵 지형을 돌아다니며 미션을 수행 -
- 오리들은 맵 지형을 돌아다니며 미션을 수행 or 거위 유저 PK


## 링크

PPT : [**피피티 링크**](https://drive.google.com/file/d/1ppwYuHgQoguHYDg1hzDyn630N888WWXh/view?usp=drive_link)

Github : [**깃허브 링크**](https://github.com/yootaeheon/NetworkPorject_9team)

시연영상 : [**시연영상 링크**](https://youtu.be/jxV1I70Prko)

프로젝트 관리 : [**노션 링크**](https://www.notion.so/9-9s9sDuck-153f51ab999e80a2b554d222c80a082b?pvs=21)

## 목차

### 구현 컨텐츠

1. Photon을 이용한 Pun2 Voice 적용
2. 투표 시스템 구현

### 이슈 및 해결사항

1. 네트워크 지연으로 인한 RPC 중복 호출 문제


# **Ⅱ**. 구현 컨텐츠

# **1. Photon을 이용한 Pun2 Voice 적용**

## 1.1 구상

실시간 음성 채팅 기능 구현

- 게임 중 플레이어 생존 여부에 따른 보이스 그룹 분리
- 플레이어 거리에 비례한 사운드 볼륨 조절

## 1.2 설계 방법

### **Lobby와 Game 씬 내에서 보이스 적용하여 의사소통 가능 구현**

- 각 씬에 Pun Voice Client와 Recorder 컴포넌트가 있는 Voice 오브젝트가 있으며 각 플레이어 프리팹에는 **PhotonVoiceView**가 있어 씬 로드 시 자동으로 보이스 적용되게 구현
- Speaker 컴포넌트를 추가한 Speaker 프리팹 생성하여 Pun Voice Client에 참조하여 로드 시 자동 생성

### **플레이어 생존 여부에 따른 보이스 그룹 분리**

- **구현 기술**
    - Recorder 클래스의 InterestGroup 사용하여 구현
    - VoiceManager 스크립트에 byte 배열로 생존자 그룹과 사망자 그룹 변수 선언
    - 사망 시 호출되는 이벤트에 ChangeGroup() 매서드를 연결하여 사망 시, InterestGroup의 인덱스를 2로 변경
    
- OpChangeGroups 함수에서 삭제 채널과 생성 채널 인자값을 각각 필드에 선언한 생존자 그룹과 사망자 그룹으로 함
- 생존자는 생존자 그룹끼리 보이스 소통 가능하며 사망자는 사망자 그룹 끼리 보이스 소통 가능
    
    
- **해당 방식을 사용한 이유**
    - 유연한 동적 관리 가능
        - 런타임 중 동적으로 그룹을 관리 가능하며 즉각적으로 보이스 그룹 전환이 가능
        - 생존자와 사망자 그룹을 별도로 관리함으로써, 게임 플레이 중 상태 변화에 유연하게 대응 가능
        

### **플레이어 간 거리에 비례하여 보이스 사운드 크기 조절**

- **구현 기술**
    - 플레이어의 자식 오브젝트로 생기는 스피커의 Transform을 SpeakerMover 클래스로 고정
    
    - LocalPosition을 Vector3.Zero로 고정하여 스피커 위치를 플레이어에게 부착
    
    - Speaker의 AudioSource 컴포넌트의 Spatial Blend를 1로 설정하여 3D 사운드를 적용
    
    - 3D Sound Settings의 Max,Min Distance를 설정하여 멀리 있는 플레이어의 보이스를 들을 수 없게 구현
        

- **해당 방식을 사용한 이유**
    - 실시간 공간적 음향 계산
        - 플레이어 간 거리에 비례하여 사운드 볼륨 조절 기능이 필요하여 SpatialBelnd의 3D 세팅을 이용하여 기능 구현
            

# **2. 투표 시스템 구현**

## 2.1 구상

- Photon을 활용하여 실시간으로 투표 정보 갱신 및 집계 기능

## 2.2 설계 방법

### **MonoBehaviourPunCallbacks를 상속받아 콜백함수 이용 구현**

- VoteManager와 VotePanel 클래스는 투표 진행 중 추가적인 작업을 할 수 있도록 **MonoBehaviourPunCallbacks를 상속** 받아 **콜백함수를 오버라이딩하여 사용**
    - VoteManager
        - 투표 관련 로직을 처리하는 클래스
        - 플레이어 투표 수와 결과를 관리.
    - VotePanel
        - 투표 과정의 UI 관리 클래스
        

### **IPunObservable을 상속 받아 변수 동기화**

- 투표 진행 중의 변수 데이터는 VoteSceneData 클래스에서 관리되며 **IPunObservable을 상속** 받아 OnPhotonSerializeView() 매서드를 통해 **변수 데이터를 동기화**

### **RPC 기반의 실시간 투표 시스템**

- **구현 기술**
    - 투표 로직은 데디케이트 서버 방식을 활용하여 마스터 클라이언트를 거쳐 진행
        - 데디케이트 서버 방식에서 전용 서버를 통해 모두 일관된 판정을 받는 기능이 필요하여, 마스터 클라이언트가 모든 클라이언트에게 일관된 판정을 해주는 식으로 활용하여 구현
    
    - 투표 씬 로드 시 마스터 클라이언트가 플레이어 인원 수만큼 패널들을 활성화
    
    - 닉네임, 캐릭터 색깔, 사망 여부 등을 동기화
        - 사망 시 패널 버튼 비활성화 및 DidVote가 True가 되어 투표 불가 처리
            
    - 마피아끼리는 닉네임이 빨간색으로 표시
    
    - 상대 플레이어의 패널을 클릭하여 투표 가능
        - 버튼 클릭 시 Pun RPC를 이용하여 투표 대상과 본인 플레이어 넘버를 인자값으로 넘겨줌
        - VoteManager에서 VoteCount 배열에 각 플레이어 넘버에 맞는 인덱스에 득표수를 추가하여 갱신함
        - 투표 대상은 득표수 데이터가 반영되며 본인은 Did Vote 변수가 True가 되며 추가적인 투표 불가능
        
    - 스킵 버튼 클릭으로 투표 포기 기능
        - 버튼 클릭시 Pun RPC를 이용하여 SkipCount++
        - DidVote가 True가 되며 추가적인 투표 불가능
        
    - 투표 시간 종료 시 집계 기능
        - 투표 시간 종료 시 동기화된 변수를 가지고 각 플레이어의 득표수와 스킵 수만큼 이미지 활성화
        - 익명 이미지 활성화 기능은 활성화된 이미지 갯수에 따른 배치를 유동적으로 하기위하여 Content Size Filter와 Grid Layout Group 컴포넌트를 사용하여 구현
            
        - for 문으로 각 플레이어의 득표수를 비교하며 더 큰 값을 top 변수에 저장 및 대상 플레이어 인덱스 번호 저장
        - top 변수와 같은 값이 있을 시 sameCount ++ 이 이루어지며 for 문 종료 시에 sameCount가 1이면 당선되며 1보다 클 시에 동점자 발생으로 투표 무효 처리
        - 당선자의 플레이어 넘버 인덱스를 받아 Die() 함수 호출로 사망처리
        
    - 각 플레이어 패널은 PhotonView와 PhotonTransformView를 가지고 있어 투표씬에서 모든 플레이어가 같은 화면을 볼 수 있게 동기화
        

- **해당 방식을 사용한 이유**
    - 정확한 투표 결과 반영
        - 데디케이트 서버 방식을 활용하여 모든 플레이어 간의 데이터를 일관되게 유지하며 투표를 진행할 수 있으며며. 현재 투표 상태, 득표수, 스킵 수 등의 데이터를 정확히 동기화 가능
        - 이를 통해, 네트워크 지연이나 클라이언트 간 데이터 불일치 문제 해결 가능
    - 득표수 배열로 관리
        - 최대 플레이어 수가 고정되어 있어 배열의 크기가 미리 정해져 있으므로, 불필요한 메모리 할당 없이 메모리 사용을 최소화
        - 배열은 인덱스 기반으로 관리하므로 시간 복잡도 O(1)로 빠른 접근이 가능하여 실시간으로 동작하는 기능에서 성능적 이점을 가짐
            

# Ⅲ. 이슈 및 해결 사항

## 1. 네트워크 지연으로 인한 RPC 중복 호출 문제

### 원인

플레이어 측 네트워크 지연으로 인하여 투표 과정에서 **RPC 중복 호출**이 발생함

오류로 인하여 한 플레이어가 투표를 2번 이상할 수 있는 문제가 생김

### 해결 방법

투표 실시 플래그를 생성하여 해결

⇒ 각 플레이어가 투표를 실시 후에 해당 플레이어의 투표 여부를 나타내는 **DidVote 변수를 True**로 설정하여, 이미 투표한 플레이어는 **추가 투표가 불가능**하도록 제한
